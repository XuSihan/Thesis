% !TeX root = ../main.tex
% -*- coding: utf-8 -*-

\chapter{基于相关统计量的缺陷定位}
本章的研究内容主要针对一种重要的纠错性软件维护手段--缺陷定位。本章首先描述了缺陷定位对维护软件正确性
的作用，然后描述了基于程序谱的缺陷定位方法的一般过程。针对程序中可能存在多错误的问题，本文提出了基于
相关统计量的可疑度计算方法，在计算过程中尽可能避免多错误之间的相互影响。接着阐述了实验评估部分，描述
了实验设置，包括实验对象、对比实验和评价指标。在展示了实验结果和分析之后，对本章进行小结。

\section{引言}
软件系统在当今社会的军事、生活、教育等各个方面占据着重要的地位。随着人们对软件系统依赖性的不断增强，
软件系统失效往往给生活和经济带来巨大的损失，尤其在军事、航空等对可靠性有高要求的行业。软件缺陷是导致
软件失效的主要因素。软件缺陷的存在可能导致软件系统不能按照预期执行，从而造成误差甚至系统崩溃。为了保
证软件正确性，需要软件维护人员及时清除可能导致软件失效的缺陷。

当软件系统失效时，需要对软件系统进行纠错性软件维护，将潜在的软件缺陷清除。缺陷定位指的是当软件失效
时，查找并定位软件缺陷的过程，是纠错性软件维护的基础。虽然缺陷定位是纠错性软件维护的首要条件，但是人
工进行缺陷定位往往是一个冗长而繁复的过程。一方面人工缺陷定位通常依赖软件维护人员的经验和对软件系统的了解，
即使经验丰富的软件维护人员也很难迅速定位导致软件系统行为失效的根本原因。另一方面，针对大规模软件系统，人工缺陷定位所消耗的时间较长，软件维护人员需要充分理解源代码后逐步排查。

为了帮助软件维护人员查找缺陷，研究者们在自动缺陷定位的研究上投入了大量的工作。当前主要的缺陷定位方法
包括基于覆盖分析的方法、基于程序切片的方法、基于程序不变量的方法、基于模型检验的方法、基于状态变更的
方法等。其中大多数方法通过对软件系统的源代码或行为进行建模，查找与软件系统失效的代码。根据建模对象的
不同，传统的缺陷定位方法可以分为动态分析和静态分析两类。前者通过动态分析程序的行为，如执行路径或状态
等，查找相关代码；后者主要通过静态分析软件系统的源代码，从而分析与软件系统失效行为有关的程序元素。虽
然自动化缺陷定位的理论和技术得到了很大的发展，但当前的自动缺陷定位仍然面临两个挑战：

\begin{itemize}
      \item 随着需求的不断增加，软件系统越来越大，导致缺陷定位的效率降低。因此，适用于大规模软件系统的
   的缺陷定位越来越得到关注。
      \item 软件系统中潜在的缺陷可能不止一个，多个软件缺陷之间的相互影响可能导致自动缺陷定位的难度提
      高，准确度下降。尽管目前已经存在部分针对多缺陷的调试技术，但多缺陷的自动定位仍然是不小的挑战。
\end{itemize}

基于覆盖分析的缺陷定位方法，其核心思想是被失效用例执行越多、成功用例执行越少的代码可疑度越高。该类方
法通常只需要统计测试用例的执行结果和覆盖信息，并根据特定的公式计算代码的可疑度，不需要对软件系统的源
代码进行建模，因此计算复杂度低，在面对大规模软件系统时效率较高。然而，引起测试用例失效的软件缺陷可能
不止一个，忽略不同软件缺陷之间的相互影响，可能导致缺陷定位的准确性降低。其主要原因有两个方面：（1）
未被失效用例覆盖的代码可能也包含缺陷；（2）不同软件缺陷共同路径上的正确代码被失效用例覆盖的频率较
大，导致可疑度偏高。本文引入相关统计量的概念，通过将测试用例执行的覆盖信息作为特征，测试用例执行结果
作为标签，将原问题转化为数据挖掘问题，从而推测特征（代码）对执行结果的重要性。

本章具有以下贡献：
\begin{itemize}
      \item 本章提出了基于相关统计量的缺陷定位方法，从数据的角度分析测试用例的覆盖信息，利用特征选择
中特征对分类结果重要性的概念，将对测试用例执行结果影响较大的代码的可疑度提高。
      \item 该方法在传统的基于覆盖分析的缺陷定位方法上引入了相关统计量，同样不需要对源代码进行建模，计算复杂度较低。
      \item 针对多缺陷之间相互影响的问题，相关统计量为每个测试用例选择距离最近的同类和异类样本，计算
      测试用例在每个特征上距离同类和异类的距离，从而计算特征对测试执行结果的重要性。该方法在很大程度
      上避免了在衡量特征重要性时多错误之间的相互影响。
      \item 在开源软件系统上的实验证明，本章方法相比较传统启发式的基于覆盖分析的缺陷定位方法在准确性
      上具有一定的提升，通过提高缺陷查找效率缩短了纠错性维护的时间和人力成本。
\end{itemize}

\section{研究动机与相关工作}
基于覆盖分析的缺陷定位技术，通过程序谱的方式将测试用例的执行覆盖信息表现出来，并统计判断程序的执行结果，最后根据特定的可疑度计算公式逐个计算每个程序元素的可疑度，并按照可疑度由高至低排序推荐给软件维护人员。

\subsection{相关定义}
\begin{Definition}
      程序。程序$P$由代码序列表示，记作$P=\{e_1, e_2, e_3, ..., e_n\}$，其中$e$表示程序元素，根据程序元素的不同，程序覆盖信息可分为关于语句、谓词、分支、变量定义-使用对等。
\end{Definition}

\begin{Definition}
      软件缺陷。软件缺陷是程序中存在的对程序行为具有破坏能力的错误或功能缺陷，记作$d$。
\end{Definition}

\begin{Definition}
      成功用例。当且仅当程序$P$的输出与预期预期输出一致时，称测试用例为成功用例$t$，成功用例集记作
      $T_t$。
\end{Definition}

\begin{Definition}
      失效用例。当程序$P$的输出与预期预期输出不一致时，称测试用例为失效用例$f$，失效用例集记作$T_f$
\end{Definition}

\begin{Definition}
      程序谱。程序谱$S$由$m\times n$的矩阵构成，其中$m$为测试用例的个数，$n$为程序元素的个数。用
      $S_{ij}=true$表示第$i$个测试用例覆盖了第$j$个程序元素；$S_{ij}=false$表示第$i$个测试用例未覆盖
      第$j$个程序元素。
\end{Definition}

\begin{figure}[htp]
      \centering
      \includegraphics[width=0.95\linewidth]{spectra.pdf}
      \caption{示例程序的分支覆盖特征谱}
      \label{fig:spectra}
\end{figure}

本章以分支覆盖特征谱为例，提出了基于相关统计量的缺陷定位方法。值得注意的是，本章方法也同样适用于其它
程序元素。图~\ref{fig:spectra}是示例程序的分支覆盖特征谱，示例代码来自于西门子标准集
\footnote{http://sir.unl.edu/portal/index.php}。图~\ref{fig:spectra}中的示例代码共有2个嵌套的分支结
构，分别是$B_1$和$B_2$。对于每个分支结构，我们用分别用$t$和$f$来示意其两个分支，如$B_1.t$表示第一个
分支结构的真分支。根据分支情况将示例代码分为五个部分，可表示为$P = \{E, B_1.t, B_1.f, B_2.t,
B_2.f\}$，其中$E$表示程序的入口代码快。图~\ref{fig:spectra}中共有8个测试用例，每个测试用例的覆盖信息
表示为一列，黑色原型表示该测试用例覆盖了所对应的程序元素。灰色阴影的测试用例表示该用例的执行结果为失
效；反之则为成功用例。

图~\ref{fig:spectra}中使用三种经典的可疑度计算方法，分别是Tarantula~\cite{jones2005empirical}、
Jaccard~\cite{abreu2007accuracy}和Ochiai~\cite{abreu2007accuracy}，可疑度计算公式如下：
\begin{eqnarray}
 susp_T = \frac{\frac{a_{11}}{a_{11}+a_{01}}}{\frac{a_{11}}{a_{11}+a_{01}}+\frac{a_{10}}{a_{10}+a_{00}}}, \label{eq:tar}\\
susp_J = \frac{a_{11}}{a_{11}+a_{01}+a_{10}}, \label{eq:jac}\\
susp_O = \frac{a_{11}}{\sqrt{(a_{11}+a_{01})\times(a_{11}+a_{10})}}, \label{eq:och}
\end{eqnarray}

上述公式中的四个变量均用来描述程序元素覆盖与否信息与执行结果之间的关系：
\begin{itemize}
  \item $a_{00}$表示测试用例被成功执行但未覆盖某个程序元素；
  \item $a_{01}$表示测试用例执行失效且未覆盖某个程序元素；
  \item $a_{10}$表示测试用例被成功执行且覆盖某个程序元素；
  \item $a_{11}$表示测试用例执行失效且覆盖了某个程序元素。
\end{itemize}

\subsection{研究动机}
传统的基于覆盖分析的缺陷定位方法，基于启发式的思想使用特定公式计算程序元素的可疑度，其优点在于计算复
杂度低，面对大规模软件系统的效率较高，但也存在一定的问题：由于基于覆盖分析的方法不对程序源代码进行建
模，而是从统计的角度根据代码被失效和成功覆盖的频率推测代码的可疑度，因此对于存在多错误的失效用例，难
以区分不同缺陷导致的失效用例，而缺陷之间的相互影响是导致多缺陷定位的准确性下降的主要原因。

以图~\ref{fig:spectra}中的示例代码为例，该代码片段中存在两个缺陷$d_1$和$d_2$，分别在分支结构$B_2$的
真假分支$B_2.t$和$B_2.f$上。失效用例集为$T_f=\{t_1, t_4, t_5, t_8\}$，其中测试用例$t_1, t_5, t_8$覆
盖$d_1$，用例$t_4$覆盖$d_2$。由图~\ref{fig:spectra}可以看出，由于示例代码存在两个缺陷，导致对于每个
缺陷，都存在不覆盖该缺陷的失效用例。例如对于缺陷$d_2$，虽然被失效用例$t_4$覆盖，但是由于缺陷$d_1$的
存在，导致大多数失效用例都不需要覆盖缺陷$d_2$，因此按可疑度比实际偏低。图~\ref{fig:spectra}中的三个
可疑度计算结果可以看到，分支$B_2.f$的可疑度远远比$B_2.t$低，甚至比$E$的可疑度更低。值得注意的是，由
于分支$B_1.t$存在于两个缺陷的共同路径上，因此其被所有的失效用例覆盖，导致其可疑度比实际偏高。

为了说明缺陷个数和基于覆盖分析的可疑度计算之间的关系，本文用$\alpha$表示其被失效用例覆盖的次数占失效
用例总数的比例，即
\begin{eqnarray}
\alpha = \frac{a_{11}}{a_{11}+a_{01}}。 \label{eq:alpha}
\end{eqnarray}
当程序中只存在一个缺陷$d$时，所有失效用例均覆盖该缺陷，因此不存在未覆盖该缺陷却导致测试用例失效的情
况，缺陷所对应的$a_{01}=0$，导致$\alpha=1$永远成立；而当程序中存在不止一个缺陷时，导致测试用例失效的
缺陷可能不止一个，覆盖其中一个或多个缺陷的测试用例都有可能会触发缺陷，导致软件行为失效，因此可能存在
失效用例只覆盖其中部分缺陷，因此缺陷所对应的$a_{01}>=0$，此时$\alpha<=1$；随着具有破坏程序行为能力的
缺陷个数越来越多，每个缺陷所触发的失效用例占失效用例总数比例越来越小，此时$\alpha$也随之变小。

以Tarantula\cite{jones2005empirical}为例，使用$\alpha$可将公式~\ref{eq:tar}表示为：
\begin{eqnarray}
 susp_T = \frac{1}{1+\frac{|T_p|}{\alpha}}, \label{eq:t}
\end{eqnarray}
其中$|T_p|$表示成功用例的个数。从公式~\ref{eq:t}中可以看出，随着软件中包含的缺陷越来越多，由于每个缺
陷所导致的失效用例占总失效用例的比例下降，导致包含缺陷的程序元素所对应的$\alpha$变小，因此缺陷的可疑
度$susp_T$降低，从而影响了缺陷定位的准确度和效率。

\subsection{多缺陷定位相关工作}
在早期研究中，有研究者提出``One-bug-at-a-time''~\cite{klahr1988cognitive}，将多缺陷程序视为单缺陷程
序进行定位，在修复缺陷后若还存在失效用例，则继续缺陷定位并修复。这种方法由于忽略了缺陷之间的相互影
响，导致定位缺陷的准确率较低，且由于需要重复执行测试用例集，因此效率较低。

一种理想的解决方式是将由不同缺陷导致的失效用例划分成为不同的失效用例集，对其中每个失效用例集可视为当
前程序只存在一个可触发程序失效的缺陷，其余缺陷均不能引起程序行为失效。在这种情况下，所有失效用例均覆
盖包含缺陷的代码，此时缺陷代码的$a_{01}=0$，因此$\alpha$取得最大值。根据公式~\ref{eq:t}可知，当
$\alpha$取最大值时，缺陷代码的可疑度最高。这种方法的优点在于每个失效用例集均来自于同一缺陷，因此测试用例的直观性比较强，使用单缺陷定位方法能够快速定位到缺陷。

为了达到这个效果，部分学者使用聚类分析将失效用例进行聚类~\cite{jones2007debugging,
zheng2006statistical}，对每类失效用例采用单缺陷的方法进行处理。基于聚类分析的方法，其核心思想是由相
同缺陷引起的失效用例其程序行为相似，具有相似的覆盖信息。这种方法虽然在一定程度上提高了多缺陷的定位准
确率，但是依赖聚类分析的准确性，很难完全避免多缺陷之间的相互影响。

文万志等人~\cite{conslice2013}提出使用条件切片进行多缺陷定位，该方法根据输入条件的不同计算出不同的条
件切片，将失效用例进行划分，每类失效用例被视为由同一缺陷引发，最后通过基于覆盖分析的缺陷定位技术计算
可疑度。该方法与基于聚类分析的方法类似，其最终目的是将多缺陷程序当做单缺陷程序处理，在依赖划分准确性
的同时忽略了缺陷之间的相互影响；与之不同的是，本文方法不需要对失效用例进行划分，且不需要进行条件切
片。

基于失效用例划分的多缺陷定位方法~\cite{zheng2006statistical, jones2007debugging, conslice2013}虽然在
一定程度上提高了多缺陷定位的效率，但其准确度依赖于失效用例划分的质量。不准确的划分使得同一失效用例集
中包含来自多个缺陷的失效用例，因此容易导致混入由其它缺陷导致的失效用例，从而引入噪音；除此以外，由于
划分导致每个失效用例集的规模变小，因此可能引起缺陷定位的不准确性。

何加浪等人~\cite{neural2013}提出使用神经网络定位多缺陷，该方法通过学习输入和缺陷之间的关系，计算代码
的各个位置与每个缺陷之间的相关性来定位缺陷。该方法利用神经网络的泛化能力学习代码和缺陷的相关性，需要
提前假定程序中的缺陷个数。而在实际应用中，软件维护人员很难提前知道潜在的缺陷个数。与之不同的是，本文
方法对缺陷个数不敏感，无需假定程序中存在的缺陷个数，且计算复杂度较低，更适用于大规模软件系统。

\section{基于相关统计量的缺陷定位算法}
本章在基于覆盖分析的缺陷定位技术的基础上引入了相关统计量的概念，从数据挖掘的角度计算代码对程序执行结果的重要性，通过为每个测试用例寻找距离最近的测试用例，在很大程度上避免了多缺陷相互之间的影响，提升了缺陷定位的效率和准确率。

\subsection{基于覆盖分析的缺陷定位}
以分支覆盖特征谱为例，基于覆盖分析的缺陷定位过程主要包括以下三步：
（1）运行测试用例，收集测试用例运行过程中的分支覆盖信息，得到分支覆盖特征谱矩阵；
（2）根据分支覆盖特征谱矩阵计算每个基本块的可疑度；
（3）按照可疑度大小由高至低推荐给软件维护人员进行逐个排查。

如图~\ref{fig:fault_flow}所示，本文在
给定程序$P$，选择一种程序元素（如语句、分支、定义对等）记录测试用例执行过程中的覆盖信息。
\begin{figure}[htp]
      \centering
      \includegraphics[width=0.9\linewidth]{fault_flow.pdf}
      \caption{方法过程}
      \label{fig:fault_flow}
\end{figure}

\subsection{相关统计量}
具体来说，Relief为每个测试用例寻找距离最近的同类和异类样本，距离同类越近、距离异类越远的特征被认为越能够区分不同类别的样本。
\subsection{可疑度计算方法}
\section{实验设置}
\subsection{实验对象}
\subsection{对比实验}
\subsection{评价指标}
\section{实验结果与分析}
\subsection{实验结果}
\subsection{结果分析}
\subsection{适用性讨论}
依赖测试用例集的质量。如果特别不平衡的话，还是容易导致某些缺陷被放大，某些缺陷被缩小。
\section{本章小结}
本章提出在覆盖分析的基础上使用相关统计量来定位缺陷，通过为每个测试用例选择距离其最近的同类和异类测试
用例，为每个失效用例找到最有可能与其由同一缺陷出发的失效用例。虽然基于相关统计量的缺陷定位与聚类分析
的方法是基于相似的核心思想，即由相同缺陷引起的失效用例具有一定的相似性，但本文方法在该思想的基础上加
了较大的约束，即本文认为只有距离失效用例最近的失效用例才可能由同一缺陷引起，因此在很大程度上避免了对
聚类分析准确性的依赖，且不需要聚类分析中的参数设置（如缺陷个数等参数）。
