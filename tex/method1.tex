% !TeX root = ../main.tex
% -*- coding: utf-8 -*-

\chapter{基于相关统计量的缺陷定位}
本章的研究内容主要针对一种重要的纠错性软件维护手段--缺陷定位。本章首先描述了缺陷定位对维护软件正确性
的作用，然后描述了基于程序谱的缺陷定位方法的一般过程。针对程序中可能存在多错误的问题，本文提出了基于
相关统计量的可疑度计算方法，在计算过程中尽可能避免多错误之间的相互影响。接着阐述了实验评估部分，描述
了实验设置，包括实验对象、对比实验和评价指标。在展示了实验结果和分析之后，对本章进行小结。

\section{引言}
软件系统在当今社会的军事、生活、教育等各个方面占据着重要的地位。随着人们对软件系统依赖性的不断增强，
软件系统失效往往给生活和经济带来巨大的损失，尤其在军事、航空等对可靠性有高要求的行业。软件缺陷是导致
软件失效的主要因素。软件缺陷的存在可能导致软件系统不能按照预期执行，从而造成误差甚至系统崩溃。为了保
证软件正确性，需要软件维护人员及时清除可能导致软件失效的缺陷。

当软件系统失效时，需要对软件系统进行纠错性软件维护，将潜在的软件缺陷清除。缺陷定位指的是当软件失效
时，查找并定位软件缺陷的过程，是纠错性软件维护的基础。虽然缺陷定位是纠错性软件维护的首要条件，但是人
工进行缺陷定位往往是一个冗长而繁复的过程。一方面人工缺陷定位通常依赖软件维护人员的经验和对软件系统的了解，
即使经验丰富的软件维护人员也很难迅速定位导致软件系统行为失效的根本原因。另一方面，针对大规模软件系统，人工缺陷定位所消耗的时间较长，软件维护人员需要充分理解源代码后逐步排查。

为了帮助软件维护人员查找缺陷，研究者们在自动缺陷定位的研究上投入了大量的工作。当前主要的缺陷定位方法
包括基于覆盖分析的方法、基于程序切片的方法、基于程序不变量的方法、基于模型检验的方法、基于状态变更的
方法等。其中大多数方法通过对软件系统的源代码或行为进行建模，查找与软件系统失效的代码。根据建模对象的
不同，传统的缺陷定位方法可以分为动态分析和静态分析两类。前者通过动态分析程序的行为，如执行路径或状态
等，查找相关代码；后者主要通过静态分析软件系统的源代码，从而分析与软件系统失效行为有关的程序元素。虽
然自动化缺陷定位的理论和技术得到了很大的发展，但当前的自动缺陷定位仍然面临两个挑战：

\begin{itemize}
      \item 随着需求的不断增加，软件系统越来越大，导致缺陷定位的效率降低。因此，适用于大规模软件系统的
   的缺陷定位越来越得到关注。
      \item 软件系统中潜在的缺陷可能不止一个，多个软件缺陷之间的相互影响可能导致自动缺陷定位的难度提
      高，准确度下降。尽管目前已经存在部分针对多缺陷的调试技术，但多缺陷的自动定位仍然是不小的挑战。
\end{itemize}

基于覆盖分析的缺陷定位方法，其核心思想是被失效用例执行越多、成功用例执行越少的代码可疑度越高。该类方
法通常只需要统计测试用例的执行结果和覆盖信息，并根据特定的公式计算代码的可疑度，不需要对软件系统的源
代码进行建模，因此计算复杂度低，在面对大规模软件系统时效率较高。然而，引起测试用例失效的软件缺陷可能
不止一个，忽略不同软件缺陷之间的相互影响，可能导致缺陷定位的准确性降低。其主要原因有两个方面：（1）
未被失效用例覆盖的代码可能也包含缺陷；（2）不同软件缺陷共同路径上的正确代码被失效用例覆盖的频率较
大，导致可疑度偏高。本文引入相关统计量的概念，通过将测试用例执行的覆盖信息作为特征，测试用例执行结果
作为标签，将原问题转化为数据挖掘问题，从而推测特征（代码）对执行结果的重要性。

本章具有以下贡献：

（1）本章提出了基于相关统计量的缺陷定位方法，从数据的角度分析测试用例的覆盖信息，利用特征选择中特征
对分类结果重要性的概念，将对测试用例执行结果影响较大的代码的可疑度提高。

（2）该方法在传统的基于覆盖分析的缺陷定位方法上引入了相关统计量，同样不需要对源代码进行建模，计算复
杂度较低。

（3）针对多缺陷之间相互影响的问题，相关统计量为每个测试用例选择距离最近的同类和异类样本，计算测试用
例在每个特征上距离同类和异类的距离，从而计算特征对测试执行结果的重要性。该方法在很大程度上避免了在衡
量特征重要性时多错误之间的相互影响。

（4）在开源软件系统上的实验证明，本章方法相比较传统启发式的基于覆盖分析的缺陷定位方法在准确性上具有
一定的提升，通过提高缺陷查找效率缩短了纠错性维护的时间和人力成本。


\section{研究动机与相关工作}
传统的基于覆盖分析的缺陷定位方法，基于启发式的思想使用特定公式计算程序元素的可疑度，其优点在于计算复
杂度低，面对大规模软件系统的效率较高，但也存在一定的问题：由于基于覆盖分析的方法不对程序源代码进行建
模，而是从统计的角度根据代码被失效和成功覆盖的频率推测代码的可疑度，因此对于存在多错误的失效用例，难
以区分不同缺陷导致的失效用例，而缺陷之间的相互影响是导致多缺陷定位的准确性下降的主要原因。

\subsection{研究动机}
\begin{figure}[htp]
      \centering
      \includegraphics[width=0.95\linewidth]{spectra.pdf}
      \caption{示例程序的分支覆盖特征谱}
      \label{fig:spectra}
\end{figure}

图~\ref{fig:spectra}是示例程序的分支覆盖特征谱，示例代码来自于西门子标准集
\footnote{http://sir.unl.edu/portal/index.php}。图~\ref{fig:spectra}中的示例代码共有2个嵌套的分支结
构，分别是$B_1$和$B_2$。对于每个分支结构，我们用分别用$t$和$f$来示意其两个分支，如$B_1.t$表示第一个
分支结构的真分支。根据分支情况将示例代码分为五个部分，可表示为$P = \{E, B_1.t, B_1.f, B_2.t,
B_2.f\}$，其中$E$表示程序的入口代码快。图~\ref{fig:spectra}中共有8个测试用例，每个测试用例的覆盖信息
表示为一列，黑色圆圈表示该测试用例覆盖了所对应的程序元素。灰色阴影的测试用例表示该用例的执行结果为失
效；反之则为成功用例。右边三列表示用三种经典的可疑度计算公式计算出的可疑度，分别是
Tarantula~\cite{jones2005empirical}、Jaccard~\cite{abreu2007accuracy}和
Ochiai~\cite{abreu2007accuracy}。

以图~\ref{fig:spectra}中的示例代码为例，该代码片段中存在两个缺陷$d_1$和$d_2$，分别在分支结构$B_2$的
真假分支$B_2.t$和$B_2.f$上。失效用例集为$T_f=\{t_1, t_4, t_5, t_8\}$，其中测试用例$t_1, t_5, t_8$覆
盖$d_1$，用例$t_4$覆盖$d_2$。由图~\ref{fig:spectra}可以看出，由于示例代码存在两个缺陷，导致对于每个
缺陷，都存在不覆盖该缺陷的失效用例。例如对于缺陷$d_2$，虽然被失效用例$t_4$覆盖，但是由于缺陷$d_1$的
存在，导致大多数失效用例都不需要覆盖缺陷$d_2$，因此按可疑度比实际偏低。图~\ref{fig:spectra}中的三个
可疑度计算结果可以看到，分支$B_2.f$的可疑度远远比$B_2.t$低，甚至比$E$的可疑度更低。值得注意的是，由
于分支$B_1.t$存在于两个缺陷的共同路径上，因此其被所有的失效用例覆盖，导致其可疑度比实际偏高。

为了说明缺陷个数和基于覆盖分析的可疑度计算之间的关系，本文用$\alpha$表示其被失效用例覆盖的次数占失效
用例总数的比例。当程序中只存在一个缺陷$d$时，所有失效用例均覆盖该缺陷，因此不存在未覆盖该缺陷却导致
测试用例失效的情况，$\alpha=1$永远成立；而当程序中存在不止一个缺陷时，导致测试用例失效的缺陷可能不止
一个，覆盖其中一个或多个缺陷的测试用例都有可能会触发缺陷，导致软件行为失效，因此可能存在失效用例只覆
盖其中部分缺陷，此时$\alpha<=1$；随着具有破坏程序行为能力的缺陷个数越来越多，每个缺陷所触发的失效用
例占失效用例总数比例越来越小，此时$\alpha$也随之变小。

以Tarantula\cite{jones2005empirical}为例，使用$\alpha$可将公式~\ref{eq:tar}表示为：
\begin{eqnarray}
 susp_T = \frac{1}{1+\frac{|T_p|}{\alpha}}, \label{eq:t}
\end{eqnarray}
其中$|T_p|$表示成功用例的个数。从公式~\ref{eq:t}中可以看出，随着软件中包含的缺陷越来越多，由于每个缺
陷所导致的失效用例占总失效用例的比例下降，导致包含缺陷的程序元素所对应的$\alpha$变小，因此缺陷的可疑
度$susp_T$降低，从而影响了缺陷定位的准确度和效率。

\subsection{多缺陷定位相关工作}
在早期研究中，有研究者提出``One-bug-at-a-time''~\cite{klahr1988cognitive}，将多缺陷程序视为单缺陷程
序进行定位，在修复缺陷后若还存在失效用例，则继续缺陷定位并修复。这种方法由于忽略了缺陷之间的相互影
响，导致定位缺陷的准确率较低，且由于需要重复执行测试用例集，因此效率较低。

一种理想的解决方式是将由不同缺陷导致的失效用例划分成为不同的失效用例集，对其中每个失效用例集可视为当
前程序只存在一个可触发程序失效的缺陷，其余缺陷均不能引起程序行为失效。在这种情况下，所有失效用例均覆
盖包含缺陷的代码，此时缺陷代码的$a_{01}=0$，因此$\alpha$取得最大值。根据公式~\ref{eq:t}可知，当
$\alpha$取最大值时，缺陷代码的可疑度最高。这种方法的优点在于每个失效用例集均来自于同一缺陷，因此测试用例的直观性比较强，使用单缺陷定位方法能够快速定位到缺陷。

为了达到这个效果，部分学者使用聚类分析将失效用例进行聚类~\cite{jones2007debugging,
zheng2006statistical}，对每类失效用例采用单缺陷的方法进行处理。基于聚类分析的方法，其核心思想是由相
同缺陷引起的失效用例其程序行为相似，具有相似的覆盖信息。这种方法虽然在一定程度上提高了多缺陷的定位准
确率，但是依赖聚类分析的准确性，很难完全避免多缺陷之间的相互影响。

文万志等人~\cite{conslice2013}提出使用条件切片进行多缺陷定位，该方法根据输入条件的不同计算出不同的条
件切片，将失效用例进行划分，每类失效用例被视为由同一缺陷引发，最后通过基于覆盖分析的缺陷定位技术计算
可疑度。该方法与基于聚类分析的方法类似，其最终目的是将多缺陷程序当做单缺陷程序处理，在依赖划分准确性
的同时忽略了缺陷之间的相互影响；与之不同的是，本文方法不需要对失效用例进行划分，且不需要进行条件切
片。

基于失效用例划分的多缺陷定位方法~\cite{zheng2006statistical, jones2007debugging, conslice2013}虽然在
一定程度上提高了多缺陷定位的效率，但其准确度依赖于失效用例划分的质量。不准确的划分使得同一失效用例集
中包含来自多个缺陷的失效用例，因此容易导致混入由其它缺陷导致的失效用例，从而引入噪音；除此以外，由于
划分导致每个失效用例集的规模变小，因此可能引起缺陷定位的不准确性。

何加浪等人~\cite{neural2013}提出使用神经网络定位多缺陷，该方法通过学习输入和缺陷之间的关系，计算代码
的各个位置与每个缺陷之间的相关性来定位缺陷。该方法利用神经网络的泛化能力学习代码和缺陷的相关性，需要
提前假定程序中的缺陷个数。而在实际应用中，软件维护人员很难提前知道潜在的缺陷个数。与之不同的是，本文
方法对缺陷个数不敏感，无需假定程序中存在的缺陷个数，且计算复杂度较低，更适用于大规模软件系统。

与本文方法相近的方法是最近邻法~\cite{renieres2003fault}，该方法通过对每个失效用例找出与其最相似的成
功用例，并计算两者之间的不同来推测用例失效的原因。与之不同的是，本文受数据挖掘领域的特征选择所启发，
借鉴相关统计量的概念，将缺陷代码视为对测试用例执行结果影响较大的特征，提出了缺陷相关统计量，使被执行
后越容易导致用例失效的代码可疑度越高。

\section{基于相关统计量的缺陷定位算法}
本章在基于覆盖分析的缺陷定位技术的基础上引入了相关统计量的概念，从数据挖掘的角度计算代码对程序执行结
果的重要性，通过为每个测试用例寻找距离最近的测试用例，在很大程度上避免了多缺陷相互之间的影响，提升了
缺陷定位的效率和准确率。

\subsection{基于覆盖分析的缺陷定位}
\begin{figure}[htp]
      \centering
      \includegraphics[width=0.6\linewidth]{fault_flow.pdf}
      \caption{覆盖分析法的基本流程}
      \label{fig:fault_flow}
\end{figure}

如图~\ref{fig:fault_flow}所示，基于覆盖分析的缺陷定位技术（以分支为例）主要包括以下三步：

（1）运行测试用例，收集测试用例运行过程中的覆盖信息，得到分支覆盖特征谱；

（2）按照特定的可疑度计算公式为由分支划分的每个代码基本块计算可疑度；

（3）按照可疑度由高至低的顺序对程序源代码进行排查。 

\begin{Definition}
      程序。程序$P$由代码表示，记作$P=\{e_1, e_2, e_3, ..., e_n\}$，其中$e$表示特定的
      程序元素。
\end{Definition}

为了收集测试用例执行的覆盖信息，首先将程序表示为由程序元素组成的序列。常用的程序元素有语句、分支、谓
词、定义对等。根据元素的粒度不同，可以将程序元素分为语句和基本块两类，前者将程序的所有语句表示成一个
序列，记录每条语句的覆盖信息；后者将程序表示为基本块序列，每个基本块由部分程序语句组成（如分支等）。
程序元素可以是基于控制流的程序语句组合（如语句、分支等），也可以是通过数据流分析提取的变量的定义-使
用对，通过关注在成功和失效用例中变量的使用情况来定位缺陷，还可以是其它与程序行为相关的关键代码，如谓
词等。程序元素的多样性使得基于覆盖分析的缺陷定位技术更加灵活和高效。

\begin{Definition}
      软件缺陷。软件缺陷是程序中存在的对程序行为具有破坏能力的错误或功能缺陷，记作$d$。
\end{Definition}

\begin{Definition}
      成功用例。执行测试用例，当且仅当程序$P$的输出与预期输出一致时，称该测试用例为成功用例，成功用
      例集记作$T_t$。
\end{Definition}

\begin{Definition}
      失效用例。执行测试用例，当程序$P$的输出与预期输出不一致时，称该测试用例为失效用例，失效用例集
      记作$T_f$。
\end{Definition}

软件缺陷是导致程序行为与预期不同的主要原因，纠错性软件维护通过查找和修复软件缺陷，提高软件系统的可靠
性。根据测试用例执行的结果是否与预期一致，可以将测试用例集划分为成功用例和失效用例两类。成功执行的测
试用例可能未覆盖软件缺陷，也可能覆盖但并未出发软件缺陷；相反，失效执行的测试用例覆盖并触发至少一个软
件缺陷，导致程序的正常行为被破坏，与预期不一致。

\begin{Definition}
      程序谱。给定程序$P$和测试用例集$T$，程序谱用来记录测试用例集$T$对程序$P$在执行过程中的覆盖信
      息，记作二维矩阵$S_{m\times n}$，其中$m$表示测试用例集的规模，$n$为程序中所含程序元素的个数。
      矩阵元素$S_{ij}$为
      \begin{eqnarray}
         S_{ij} = \begin{cases} 1, & \mbox{第}i\mbox{个测试用例覆盖了第}j\mbox{个程序元素} \\ 
  0, & \text{ 其它 }  
  \end{cases}   , 1 \leqslant i \geqslant  m, 1 \leqslant j \geqslant n
      \end{eqnarray}
\end{Definition}

在确定程序元素后，通过插桩技术记录测试用例执行过程中是否覆盖特定的程序元素，并将结果记录在程序谱
中。需要注意的是，程序谱只记录程序元素的是否被测试用例覆盖，并不记录测试用例执行的顺序，因此程序谱通
常是二维0-1矩阵，其所占内存与测试用例集的规模和程序规模有关，通常在可接受范围内。

\begin{Definition}
     可疑度。程序$P$中的语句或基本块$e$包含缺陷的可能性为其可疑度，记作$suspiciousness(e)$。
\end{Definition}

经典的可疑度计算方法有Tarantula~\cite{jones2005empirical}、Jaccard~\cite{abreu2007accuracy}和
Ochiai~\cite{abreu2007accuracy}，其计算公式如下：
\begin{eqnarray}
 susp_T = \frac{\frac{a_{11}}{a_{11}+a_{01}}}{\frac{a_{11}}{a_{11}+a_{01}}+\frac{a_{10}}{a_{10}+a_{00}}}, \label{eq:tar}\\
susp_J = \frac{a_{11}}{a_{11}+a_{01}+a_{10}}, \label{eq:jac}\\
susp_O = \frac{a_{11}}{\sqrt{(a_{11}+a_{01})\times(a_{11}+a_{10})}}, \label{eq:och}
\end{eqnarray}

上述公式中的四个变量均用来描述程序元素覆盖与否信息与执行结果之间的关系：
\begin{itemize}
  \item $a_{00}$表示测试用例被成功执行但未覆盖某个程序元素；
  \item $a_{01}$表示测试用例执行失效且未覆盖某个程序元素；
  \item $a_{10}$表示测试用例被成功执行且覆盖某个程序元素；
  \item $a_{11}$表示测试用例执行失效且覆盖了某个程序元素。
\end{itemize}

基于覆盖分析的缺陷定位方法，除部分结合切片技术的方法~\cite{conslice2013,wen2013}外，其大致流程通常不
变，通过改变可疑度计算公式来提高方法的准确率和效率。缺陷定位的目的是查找引起程序行为失效的程序代码。
不考虑外部因素，失效用例的执行路径至少覆盖一个软件缺陷，且不覆盖软件缺陷的测试用例一定是成功用例。因
此，是否覆盖缺陷代码与测试用例否失效之间存在一定的相关性。本文假设是否覆盖缺陷代码是判断程序行为是否
失效的重要因素，借鉴特征选择中的相关统计量概念计算代码对程序行为结果的重要性，从而定位软件缺陷。如图
~\ref{fig:fault_flow}所示，在基于覆盖分析的缺陷定位基础上，受特征选择启发，引入了相关统计量的概念，
并提出了缺陷相关统计量来计算代码的可疑度，提高了定位缺陷的额准确率和效率。

\subsection{Relief特征选择模型}
现实问题中往往存在大量的特征，然而不是所有特征都与任务目标有关。根据与任务目标的相关性，可以将特征分
为无关特征和相关特征两类。与任务目标毫无关联的特征一般被称为``无关特征''，大量的无关特征可能会导致特
征的维度过高，造成``维度灾难''，同时可能导致训练难度的提高。因此，去掉无关特征可以在降低数据维度的同
时降低训练难度，对模型训练是有益的。另一类与任务目标有关的特征通常被称为``有关特征''，然而有关特征之
间并一定是相互独立的，可能存在部分特征可以通过其它特征计算得到，这类特征通常记作``冗余特征''。虽然冗
余特征可以通过其它特征获得，但并不代表冗余特征一定是无益的。部分冗余特征通过对其它特征的整合，使得其
本身更接近学习任务，因此可以降低学习的难度。因此，冗余特征不一定要全部移除，根据特征与学习目标的关
系，可将冗余特征分为``有益特征''和``无益特征''。特征选择的目的就是去除特征集合中的与学习任务不相干的
``无关特征''，以及虽然与学习任务相关，但可以由其它特征计算而来且对学习任务没有益处的``冗余特征''。

Relief特征选择模型由Kira~\cite{kira1992feature}等人提出，最早用来针对二分类问题在数据预处理阶段进行
特征选择，从而降低数据维度。Relief特征选择模型的核心思想是通过估算特征对相似样本的区分能力来判断特征
是否对二分类学习任务有益。样本的相似性通过样本之间的距离来衡量，给定距离公式，距离越小的样本，相
似性越大。特征对相似样本的区分能力体现在，对任意一个样本以及与其最相似的同类样本和异类样本，若在某个
特征上，样本总是倾向于与同类样本的距离近，而与异类样本的距离远，则认为该特征上对相似样本具有区分能
力。

为了衡量特征对相似样本的区分能力，Kira~\cite{kira1992feature}等人引入了相关统计量的概念，计算每个特
征与二分类类别之间的相关性，并将其作为特征的权重，提出了一种基于特征权重的算法，通过移除权重低于特定
阈值的特征来进行特征选择。具体来说，给定样本集$\mathcal D=\{(x_1,y_1),(x_2,y_2),...,(x_n,y_n)\}$，其中
$x_i=\{x_{i1},x_{i2},...,x_{iq}\}$，$q$为原始特征的个数。从训练样本集$\mathcal D$中随机抽取一个样本
$(x_i,y_i)$，Relief特征选择模型分别为样本$(x_i,y_i)$寻找一个同类样本$(x_{i,nh},y_i)$（记作
$near-hit_i$）和一个异类样本$(x_{i,nm},-y_i)$（记作$near-miss_i$），然后分别计算$x_i$与$x_{i,nh}$和
$x_i$与$x_{i,nm}$在第$j$个特征上的距离之差：
\begin{equation}
       \delta^j_i = -diff(x_i^j, x_{i,nh}^j)^2 + diff(x_i^j,x_{i,nm}^j)^2, \label{eq:delta}
\end{equation}
当第$j$个特征为离散型时：
\begin{equation}
       diff(x^j_a,x^j_b) = \begin{cases} 0, & \textit{if}~x^j_a=x^j_b \\ 
  1, & \text{ otherwise, }  
  \end{cases} 
\end{equation}
当第$j$个特征为连续型时：
\begin{equation}
       \text{diff}(x^j_a,x^j_b) = |(x^j_a-x^j_b)|.
\end{equation}
重复上述过程，从样本集中随机抽取样本$M$次，得到关于第$j$个样本的相关统计量：
\begin{equation}
       \delta^j = \frac{1}{M}\sum_{i=1}^M{-diff(x_i^j, x_{i,nh}^j)^2 + diff(x_i^j,x_{i,nm}^j)^2}. 
\end{equation}

从公式~\eqref{eq:delta}中可以看出，在第$j$个特征上，当$x_i$与其最近同类$x_{i,nh}$距离小，与其最近异类
$x_{i,nm}$距离大时，说明此时该特征对区分不同类别的样本是有益的，因此增加第$j$个特征的权重
$\delta^j_i$；反之，若$x_i$与其最近同类$x_{i,nh}$距离大，而与其最近异类$x_{i,nm}$距离小时，
说明此时该特征对区分不同类别的样本是无益的，此时减小第$j$个特征的权重$\delta^j_i$。

\begin{algorithm}[H]
\caption{Relief特征选择算法}\label{alg:relief}
\KwIn{样本数据集$\mathcal D$，原始特征集$\mathcal F$，相关统计量阈值$\Gamma$，样本抽取次数$M$；}\\
\KwOut{特征子集$\mathcal {V}$，每个特征的相关统计量$\Delta$；} \\
初始化特征子集$\mathcal {V} \leftarrow \bm \emptyset$；\\ 
初始化每个特征的相关统计量$\bm \Delta^j \leftarrow \bm 0$；\\ 
根据样本标签将样本数据集$\mathcal D$划分为正类$\mathcal D^+$和负类$\mathcal D^-$；\\
\For {$i=1$ to $|M|$} {
     从样本数据集$\mathcal D$中随机抽取一个样本$(x_i,y_i)$；\\
     从数据集$\mathcal D^+$和$\mathcal D^-$中分别寻找距离$x_i$最近的两个样本，其中与$(x_i,y_i)$同类的样本为$(x_{i,nh},y_i)$，与$(x_i,y_i)$异类的样本为$(x_{i,nm},y_i)$；\\
     \For {$j=1$ to $|\mathcal F|$} {
            根据当前样本$(x_i,y_i)$计算在第$j$个特征上的相关统计量$\delta^j_i$（公式~\eqref{eq:delta}）；\\
            更新第$j$个特征的相关统计量$\delta^j \leftarrow \delta^j + \delta^j_i$；\\
     }
}
\For{$j=1$ to $|\mathcal F|$} {
      \If{$\delta^j \geqslant \Gamma$}{
            添加第$j$个特征进入特征子集$\mathcal V$；\\
      }
}

\textbf{return} 特征子集$\mathcal {V}$，特征的相关统计量$\Delta$。\\
\end{algorithm}

算法~\ref{alg:relief}为Relief特征选择模型的算法，Relef为每个测试用例寻找距离最近的同类和异类样本，距
离同类越近、距离异类越远的特征被认为越能够区分不同类别的样本。从算法~\ref{alg:relief}中可以看出
Relief特征选择的运行时间与原始特征集的规模$|mathcal F|$和样本的随机抽样次数$M$线性相关，因此该算法的
效率较高。

\subsection{缺陷相关统计量}
缺陷定位的目的是查找能够引起程序行为失效的程序代码，因此对缺陷代码的执行与程序行为失效之间必然存在某
种关联性。不考虑外部因素，失效用例的执行路径中应该覆盖一个或多个软件缺陷，而不覆盖任何缺陷代码的测试
用例理论上是一定会执行成功。因此，是否覆盖缺陷代码与测试用例执行是否失效之间存在一定的相关性。本文假
设是否覆盖缺陷代码是判断程序行为是否失效的重要因素，借鉴特征选择中的相关统计量概念计算代码对程序行为
结果的重要性，从而定位软件缺陷。在基于覆盖分析的缺陷定位基础上，受特征选择启发，引入了相关统计量的概
念，并提出了缺陷相关统计量来计算代码的可疑度，提高了定位缺陷的额准确率和效率。 受Relief特征选择算法
的启发，给定程序$P$，测试用例集$T$中的每个测试用例可视为一条样本数据。将测试用例对代码的覆盖情况作为
该测试用例的特征，根据测试用例的执行结果对其进行标记，成功用例被标记为正类、失效用例被标记为负类。测
试用例集中第$i$个测试用例可通过$T_i=\{x_{i1},x_{i2},x_{i3},...,x_{in}\}$来表示，其中$n$为程序中所含
语句或分支的个数，$x_{ij}$表示测试用例$T_i$是否覆盖第$j$个程序元素（覆盖为1，不覆盖为0）。



Relief算法

\subsection{代码排查}
The principle to map a branch or function element that is with high suspiciousness to the
corresponding code is as below: (1) If the element is one branch of the branch structure, go to (2);
else go to (5). (2) Check the corresponding branch structure judgment of this branch. (3) Check the
executable code which probably have infect on the judgment result in the basic block where the above
judgment is. (4) Check control dependent on executable code of this branch, which means whether this
branch executed or not determines whether this part of executable code execute or not, after the
check turn to (6). (5) It is time to check the function coverage feature elements. Check all
executable code that must execute in the functions, including the judgments of partial branch
structure. (6) Order the results by suspiciousness, check next feature elements. Taking branch in
Fig. 1 as example, according to step (2), firstly check judgment of the branch structure which this
branch is in, namely the fifth line code; Since there is no executable code which can influence the
judgment result and located in the same basic blocks with this fifth line code, step (3) is passed
over; Finally check the code of control independent on branch B2.f, namely sentence nine (including
other branches judgments)

\section{实验设置}
\subsection{实验对象}

\subsection{对比实验}
使用

\subsection{评价指标}
\section{实验结果与分析}
\subsection{实验结果}
\subsection{结果分析}
\subsection{适用性讨论}
本以分支覆盖特征谱为例，提出了基于相关统计量的缺陷定位方法。值得注意的是，本章方法也同样适用于其它
程序元素。
依赖测试用例集的质量。如果特别不平衡的话，还是容易导致某些缺陷被放大，某些缺陷被缩小。
\section{本章小结}
本章提出在覆盖分析的基础上使用相关统计量来定位缺陷，通过为每个测试用例选择距离其最近的同类和异类测试
用例，为每个失效用例找到最有可能与其由同一缺陷出发的失效用例。虽然基于相关统计量的缺陷定位与聚类分析
的方法是基于相似的核心思想，即由相同缺陷引起的失效用例具有一定的相似性，但本文方法在该思想的基础上加
了较大的约束，即本文认为只有距离失效用例最近的失效用例才可能由同一缺陷引起，因此在很大程度上避免了对
聚类分析准确性的依赖，且不需要聚类分析中的参数设置（如缺陷个数等参数）。

